# TypeScript_2023-01-14

<a target="_blank" href="https://velog.io/@hygoogi/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%A4%80%EB%B9%84%ED%95%98%EA%B8%B0#java"><small><strong> ✓시작 전 알아두면 좋은 OOP 관련 참고 링크</strong></small></a>

## 1. TypeScript와 OOP

### - 추상클래스(Abstract Class)

: 직접적으로 인스턴스를 만들지 못하는 클래스지만, 클래스를 상속할 수 있음

- public, private, protected
  <table style="text-align:center;" border="1">
    <thead>
      <tr>
        <th>접근가능성</th>
        <th>public</th>
        <th>protected</th>
        <th>private</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>클래스 내부</td>
        <td>O</td>
        <td>O</td>
        <td>O</td>
      </tr>
      <tr>
        <td>자식 클래스 내부</td>
        <td>O</td>
        <td>O</td>
        <td>X</td>
      </tr>
      <tr>
        <td>클래스 인스턴스</td>
        <td>O</td>
        <td>X</td>
        <td>X</td>
      </tr>
    </tbody>
  </table>
  - Abstract method : 구현되지 않은 call signature만 정의내린 method , child Class가 반드시 구현해야할 method의 call signature
      ```typescript
      //추상클래스 : 다른 클래스가 상속받을 수 있는 클래스, 직접 새로운 인스턴스를 만들 수 없음
      abstract class User {

          constructor (

            //property를 private로 만들면, 클래스를 상속하였을때도 access불가 (method도 동일)
            //속성 : public, private, protected
                //private -> 인스턴스 밖에서 접근할 수 없고, 다른 자식 클래스에서도 접근 불가
                //protected -> 인스턴스에서 직접 접근을 제외하고서는 접근 가능
            private firstName: string,
            private lastName: string,
            public nicname:string
          ) {  }

           //추상 메소드 : 추상 클래스를 상속받는 모든 것들이 구현 해야하는 메소드 의미
           // 추상 메소드 작성 :method's implementation이 아닌 call signature 작성
           abstract getNickName(argument:string) :void

          //추상 클래스 안의 method's implementation(구현)
          getFullName() {
            return `${this.firstName} ${this.lastName}`
          }
      }


      class Player extends User {

      }
      ```

## Make Hash Map

```typescript
// 제한된 양의 property 혹은 key를 가지는 타입을 정의해 주는 방식
//property에 대해서 미리 알지 못하지만, type만 알고 있을 때 씀
type Words = {
  [key: string]: string;
};

class Dict {
  private words: Words;
  constructor() {
    this.words = {};
  }
  //class를 만들때 class를 type로 사용할 수 있음 해당 파라미터가 이 클래스의 instance 이길 원하면 이렇게 쓸 수 있음
  add(word: Word) {
    if (this.words[word.term] === undefined) {
      this.words[word.term] = word.def;
    }
  }
  def(term: string) {
    return this.words[term];
  }
}

class Word {
  constructor(public term: string, public def: string) {}
}

const kimchi = new Word('김치', '한국의 대표 음식');
const dict = new Dict();

dict.add(kimchi);
dict.def('김치');
```
